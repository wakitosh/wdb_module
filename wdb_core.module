<?php

/**
 * @file
 * Primary module file for the WDB Core module.
 *
 * This file contains the primary hooks and procedural code for the module.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\wdb_core\Entity\WdbSource;
use Drupal\Core\Routing\RouteMatchInterface;

/**
 * Implements hook_theme().
 */
function wdb_core_theme($existing, $type, $theme, $path) {
  return [
    'wdb_gallery_page' => [
      'render element' => 'element',
    ],
    'wdb_annotation_info_content' => [
      'variables' => ['data' => NULL],
    ],
  ];
}

/**
 * Implements hook_form_FORM_ID_alter() for wdb_annotation_page_add_form.
 */
function wdb_core_form_wdb_annotation_page_add_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _wdb_core_alter_wdb_annotation_page_form_fields($form, $form_state);
}

/**
 * Helper function to modify WdbAnnotationPage form fields.
 *
 * @param array $form
 * The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * The current state of the form.
 */
function _wdb_core_alter_wdb_annotation_page_form_fields(&$form, FormStateInterface $form_state) {
  if (isset($form['annotation_code']['widget'][0]['value'])) {
    $form['annotation_code']['widget'][0]['value']['#type'] = 'textfield';
    $form['annotation_code']['widget'][0]['value']['#disabled'] = TRUE;
    $form['annotation_code']['widget'][0]['value']['#description'] = t('This value is automatically generated based on the referenced Source Document and Page Number after saving.');

    $entity = $form_state->getFormObject()->getEntity();
    if (!$entity->isNew() && $entity->get('annotation_code')->value) {
      $form['annotation_code']['widget'][0]['value']['#value'] = $entity->get('annotation_code')->value;
    }
    elseif ($entity->isNew()) {
      $form['annotation_code']['widget'][0]['value']['#value'] = t('(auto-generated on save)');
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for wdb_sign_function_add_form.
 */
function wdb_core_form_wdb_sign_function_add_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _wdb_core_alter_wdb_sign_function_form_fields($form, $form_state);
}

/**
 * Implements hook_form_FORM_ID_alter() for wdb_sign_function_edit_form.
 */
function wdb_core_form_wdb_sign_function_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  _wdb_core_alter_wdb_sign_function_form_fields($form, $form_state);
}

/**
 * Helper function to modify WdbSignFunction form fields.
 *
 * @param array $form
 * The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * The current state of the form.
 */
function _wdb_core_alter_wdb_sign_function_form_fields(&$form, FormStateInterface $form_state) {
  if (isset($form['sign_function_code']['widget'][0]['value'])) {
    $form['sign_function_code']['widget'][0]['value']['#type'] = 'textfield';
    $form['sign_function_code']['widget'][0]['value']['#disabled'] = TRUE;
    $form['sign_function_code']['widget'][0]['value']['#description'] = t('This value is automatically generated based on the referenced Sign Code and Function Name after saving.');
    $entity = $form_state->getFormObject()->getEntity();
    if (!$entity->isNew() && $entity->get('sign_function_code')->value) {
      $form['sign_function_code']['widget'][0]['value']['#value'] = $entity->get('sign_function_code')->value;
    }
    elseif ($entity->isNew()) {
      $form['sign_function_code']['widget'][0]['value']['#value'] = t('(auto-generated on save)');
    }
  }
}

/**
 * Implements hook_entity_insert().
 */
function wdb_core_entity_insert(EntityInterface $entity) {
  // When a new WdbSource entity is created, automatically create its
  // corresponding WdbAnnotationPage entities.
  if ($entity->getEntityTypeId() === 'wdb_source' && $entity instanceof WdbSource) {
    // The isSyncing() check is important to avoid conflicts with migrations.
    if (!$entity->isSyncing() && !isset($entity->_migration)) {
      create_annotation_pages_for_source($entity);
    }
  }

  // When a new 'subsystem' taxonomy term is created, automatically generate
  // a default configuration object for it.
  if ($entity->getEntityTypeId() === 'taxonomy_term' && $entity->bundle() === 'subsystem') {
    $config_factory = \Drupal::configFactory();
    $term_id = $entity->id();
    $config_name = 'wdb_core.subsystem.' . $term_id;

    // Only create a new config if one doesn't already exist.
    if ($config_factory->get($config_name)->isNew()) {
      $config = $config_factory->getEditable($config_name);

      // Set default values.
      $config->set('pageNavigation', 'left-to-right');
      $config->set('hullConcavity', 20);
      $config->set('allowAnonymous', FALSE);
      $config->set('iiif_server_scheme', 'https');
      $config->set('iiif_server_hostname', 'your.host.name');
      $config->set('iiif_server_prefix', 'cantaloupe/iiif/3');
      $config->set('iiif_fileExt', 'jpg');

      // Load default export templates from files.
      try {
        $module_path = \Drupal::service('extension.list.module')->getPath('wdb_core');
        $default_tei_template = file_get_contents($module_path . '/templates/export/default.tei.twig');
        $default_rdf_template = file_get_contents($module_path . '/templates/export/default.rdf.twig');

        $config->set('export_templates.tei', $default_tei_template ?: '<TEI/>');
        $config->set('export_templates.rdf', $default_rdf_template ?: '<rdf:RDF/>');
      }
      catch (\Exception $e) {
        \Drupal::logger('wdb_core')->error('Failed to load default export templates: @message', ['@message' => $e->getMessage()]);
      }

      $config->save();
      \Drupal::messenger()->addStatus(t('Created default configuration for new subsystem: @name', ['@name' => $entity->label()]));
    }
  }
}

/**
 * Implements hook_entity_update().
 *
 * Creates additional WdbAnnotationPage entities if the page count increases.
 */
function wdb_core_entity_update(EntityInterface $entity) {
  if ($entity->getEntityTypeId() === 'wdb_source' && $entity instanceof WdbSource) {
    if (!$entity->isSyncing() && !isset($entity->_migration)) {
      create_annotation_pages_for_source($entity);
    }
  }
}

/**
 * Helper function to create WdbAnnotationPage entities for a WdbSource.
 *
 * @param \Drupal\wdb_core\Entity\WdbSource $source_entity
 * The source entity that was just saved.
 */
function create_annotation_pages_for_source(WdbSource $source_entity) {
  if (!$source_entity->hasField('pages') || $source_entity->get('pages')->isEmpty()) {
    return;
  }

  $number_of_pages = (int) $source_entity->get('pages')->value;
  if ($number_of_pages <= 0) {
    return;
  }

  $ap_storage = \Drupal::entityTypeManager()->getStorage('wdb_annotation_page');

  // Find out how many pages already exist for this source.
  $query = $ap_storage->getQuery()
    ->condition('source_ref', $source_entity->id())
    ->accessCheck(FALSE);
  $existing_pages_count = $query->count()->execute();

  // Only create new pages if the total number of pages has increased.
  if ($number_of_pages > $existing_pages_count) {
    $messenger = \Drupal::messenger();
    $logger = \Drupal::logger('wdb_core');
    $created_count = 0;

    for ($page_num = $existing_pages_count + 1; $page_num <= $number_of_pages; $page_num++) {
      try {
        $ap_storage->create([
          'source_ref' => $source_entity,
          'page_number' => $page_num,
          'page_name' => t('Page @num', ['@num' => $page_num]),
          'langcode' => $source_entity->language()->getId(),
        ])->save();
        $created_count++;
      }
      catch (\Exception $e) {
        $logger->error('Failed to auto-create WdbAnnotationPage for source "@source", page @num: @message', [
          '@source' => $source_entity->label(),
          '@num' => $page_num,
          '@message' => $e->getMessage(),
        ]);
      }
    }
    if ($created_count > 0) {
      $messenger->addStatus(t('Automatically created @count new page(s) for source @source.', ['@count' => $created_count, '@source' => $source_entity->label()]));
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for wdb_annotation_page_edit_form.
 *
 * Alters the WdbAnnotationPage edit form to make some fields read-only.
 */
function wdb_core_form_wdb_annotation_page_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Disable the annotation_code field.
  if (isset($form['annotation_code'])) {
    $form['annotation_code']['widget'][0]['value']['#disabled'] = TRUE;
    $form['annotation_code']['widget'][0]['value']['#description'] = t('This code is automatically generated and cannot be changed.');
  }

  // Disable the page_number field.
  if (isset($form['page_number'])) {
    $form['page_number']['widget'][0]['value']['#disabled'] = TRUE;
    $form['page_number']['widget'][0]['value']['#description'] = t('This number corresponds to the page count of the source document and cannot be changed here.');
  }

  // Disable the source_ref field.
  if (isset($form['source_ref'])) {
    // The actual input element is typically nested.
    if (isset($form['source_ref']['widget'][0]['target_id'])) {
      $form['source_ref']['widget'][0]['target_id']['#disabled'] = TRUE;
      $form['source_ref']['widget'][0]['target_id']['#description'] = t('The source document cannot be changed after creation.');
    }
  }

  // Disable the canvas_identifier_fragment field.
  if (isset($form['canvas_identifier_fragment'])) {
    $form['canvas_identifier_fragment']['widget'][0]['value']['#disabled'] = TRUE;
    $form['canvas_identifier_fragment']['widget'][0]['value']['#description'] = t('This identifier is automatically generated and cannot be changed.');
  }
}

/**
 * Implements hook_page_attachments_alter().
 */
function wdb_core_page_attachments_alter(array &$page) {
  $route_match = \Drupal::routeMatch();
  $route_name = $route_match->getRouteName();

  // Only act on the gallery viewer page.
  if ($route_name === 'wdb_core.gallery_page') {
    // Get information to identify the current source document.
    $source_identifier = $route_match->getParameter('source');
    $subsys_name = $route_match->getParameter('subsysname');

    // Load the WdbSource entity.
    $sources = \Drupal::entityTypeManager()->getStorage('wdb_source')->loadByProperties(['source_identifier' => $source_identifier]);
    $wdb_source = NULL;
    if ($sources) {
      foreach ($sources as $source_entity) {
        /** @var \Drupal\wdb_core\Entity\WdbSource $source_entity */
        foreach ($source_entity->get('subsystem_tags')->referencedEntities() as $tag) {
          if (strtolower($tag->getName()) === strtolower($subsys_name)) {
            $wdb_source = $source_entity;
            break 2;
          }
        }
      }
    }

    if ($wdb_source) {
      // --- 1. Add all WdbSource fields as meta tags. ---
      $field_definitions = $wdb_source->getFieldDefinitions();
      $exclude_fields = ['id', 'uuid', 'langcode', 'source_identifier', 'subsystem_tags'];

      foreach ($field_definitions as $field_name => $field_definition) {
        // Skip fields in the exclusion list.
        if (in_array($field_name, $exclude_fields)) {
          continue;
        }

        // Process only if the field has a value.
        if (!$wdb_source->get($field_name)->isEmpty()) {
          $meta_contents = [];
          // Handle multi-value fields.
          foreach ($wdb_source->get($field_name) as $item) {
            $value = '';
            // Get value from common field types.
            if (isset($item->value)) {
              $value = $item->value;
            }
            // Handle entity reference fields.
            elseif (isset($item->entity)) {
              $value = $item->entity->label();
            }
            if (!empty($value)) {
              $meta_contents[] = strip_tags($value);
            }
          }

          if (!empty($meta_contents)) {
            // Use 'wdb:{field_machine_name}' as the meta tag name,
            // but use the standard 'description' for the description field.
            $meta_name = ($field_name === 'description') ? 'description' : 'wdb:' . $field_name;

            $meta_tag = [
              '#tag' => 'meta',
              '#attributes' => [
                'name' => $meta_name,
                // Concatenate multiple values and truncate.
                'content' => substr(implode(', ', $meta_contents), 0, 255),
              ],
            ];
            // Use a key to identify the meta tag.
            $page['#attached']['html_head'][] = [$meta_tag, 'wdb_meta_' . $field_name];
          }
        }
      }

      // --- 2. Add the full text as an SEO meta tag. ---
      $page_num = (int) $route_match->getParameter('page');
      $text_generator = \Drupal::service('wdb_core.text_generator');
      $text_data = $text_generator->getFullText($subsys_name, $source_identifier, $page_num);

      if (isset($text_data['html'])) {
        $full_text_snippet = substr(strip_tags($text_data['html']), 0, 500);
        $meta_seo_text = [
          '#tag' => 'meta',
          '#attributes' => [
            'name' => 'wdb:fulltext',
            'content' => $full_text_snippet . '...',
          ],
        ];
        $page['#attached']['html_head'][] = [$meta_seo_text, 'wdb_fulltext'];
      }
    }
  }
}

/**
 * Implements hook_page_attachments().
 *
 * Attaches assets to all admin pages.
 */
function wdb_core_page_attachments(array &$attachments) {
  $attachments['#attached']['library'][] = 'wdb_core/wdb_admin';
}

/**
 * Implements hook_form_alter().
 *
 * Adds a custom validation handler to the taxonomy term deletion form.
 */
function wdb_core_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($form_id === 'taxonomy_term_subsystem_delete_form') {
    // Add a custom validation function to the form's validation handlers.
    $form['#validate'][] = 'wdb_core_taxonomy_term_delete_form_validate';
  }
}

/**
 * Custom validation handler for the taxonomy term delete form.
 *
 * Prevents deletion of a subsystem term if it is in use by any WdbSource
 * entities.
 *
 * @param array $form
 * An associative array containing the structure of the form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * The current state of the form.
 */
function wdb_core_taxonomy_term_delete_form_validate(array &$form, FormStateInterface $form_state) {
  // Get the term entity being deleted from the form object.
  /** @var \Drupal\taxonomy\TermInterface $entity */
  $entity = $form_state->getFormObject()->getEntity();

  // Double-check that the entity is a term from the 'subsystem' vocabulary.
  if ($entity->bundle() === 'subsystem') {
    $term_id = $entity->id();
    $term_name = $entity->label();

    $entity_type_manager = \Drupal::entityTypeManager();

    // Use an entity query to check if any WdbSource entities reference this term.
    $source_storage = $entity_type_manager->getStorage('wdb_source');
    $query = $source_storage->getQuery()
      ->condition('subsystem_tags', $term_id)
      ->accessCheck(FALSE)
      ->range(0, 1);
    $source_ids = $query->execute();

    // If at least one is found, set a form error.
    if (!empty($source_ids)) {
      $form_state->setErrorByName(
        '', // Set the error on the whole form.
        t('The subsystem "@name" cannot be deleted because it is currently in use by one or more source documents.', ['@name' => $term_name])
      );
    }
  }
}

/**
 * Implements hook_preprocess_html().
 *
 * Overrides the site name portion of the <title> tag on WDB subsystem pages
 * with the subsystem's configured "Display Title".
 */
function wdb_core_preprocess_html(&$variables) {
  /** @var \Drupal\Core\Routing\RouteMatchInterface $route_match */
  $route_match = \Drupal::service('current_route_match');
  $subsystem_name = $route_match->getParameter('subsysname');

  // Proceed only if we are on a page with a subsystem parameter in the URL.
  if ($subsystem_name) {
    $new_site_name = '';
    $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
    $terms = $term_storage->loadByProperties(['vid' => 'subsystem', 'name' => $subsystem_name]);

    if ($subsystem_term = reset($terms)) {
      $config_id = 'wdb_core.subsystem.' . $subsystem_term->id();
      $config = \Drupal::config($config_id);
      $new_site_name = $config->get('display_title');
    }

    if (!empty($new_site_name)) {
      // The head_title array has 'title' (the page's content title) and
      // 'name' (the site's name). We override the 'name' part to change
      // what appears in the browser tab.
      $variables['head_title']['name'] = $new_site_name;
    }
  }
}
