<?php

/**
 * @file
 * Install, update and uninstall functions for the WDB Core module.
 */

use Drupal\language\Entity\ConfigurableLanguage;
use Drupal\taxonomy\Entity\Term;

/**
 * Implements hook_install().
 *
 * Performs setup tasks when the module is installed.
 */
function wdb_core_install() {
  $logger = \Drupal::logger('wdb_core');

  // 1. Ensure that required languages (en, ja) exist on the site.
  check_and_add_languages($logger);

  // 2. Update site-wide content translation settings to include WDB entities.
  update_content_translation_settings($logger);

  // 3. Create the default taxonomy terms used by the module.
  create_default_taxonomy_terms($logger);

  // 4. Create the default Part-of-Speech mapping rules.
  try {
    /** @var \Drupal\wdb_core\Service\WdbPosMappingGeneratorService $mapping_generator */
    $mapping_generator = \Drupal::service('wdb_core.pos_mapping_generator');
    $results = $mapping_generator->generateMappingsFromInternalMap();
    if (isset($results['created']) && $results['created'] > 0) {
      $logger->info('Automatically created @count POS mapping rules.', ['@count' => $results['created']]);
    }
  }
  catch (\Exception $e) {
    $logger->error('Failed to create default POS mappings: @message', ['@message' => $e->getMessage()]);
  }
}

/**
 * Helper function to check for and add required languages.
 *
 * @param \Psr\Log\LoggerInterface $logger
 * The logger service.
 */
function check_and_add_languages($logger) {
  $language_manager = \Drupal::languageManager();
  $required_langcodes = ['en', 'ja'];

  foreach ($required_langcodes as $langcode) {
    if (!$language_manager->getLanguage($langcode)) {
      try {
        $language = ConfigurableLanguage::createFromLangcode($langcode);
        $language->save();
        $logger->info('Language "@langcode" was not found and has been added to the site.', ['@langcode' => $langcode]);
      }
      catch (\Exception $e) {
        $logger->error('Failed to add language "@langcode": @message', ['@langcode' => $langcode, '@message' => $e->getMessage()]);
      }
    }
  }
}

/**
 * Helper function to update site-wide content translation settings.
 *
 * @param \Psr\Log\LoggerInterface $logger
 * The logger service.
 */
function update_content_translation_settings($logger) {
  try {
    $config_factory = \Drupal::configFactory();
    $config = $config_factory->getEditable('content_translation.settings');
    $enabled_entity_types = $config->get('enabled_entity_types') ?? [];

    $required_entity_types = [
      'taxonomy_term', 'wdb_sign', 'wdb_word', 'wdb_word_meaning',
      'wdb_sign_function', 'wdb_sign_interpretation', 'wdb_word_unit',
    ];

    $updated = FALSE;
    foreach ($required_entity_types as $entity_type) {
      if (!in_array($entity_type, $enabled_entity_types)) {
        $enabled_entity_types[] = $entity_type;
        $updated = TRUE;
      }
    }

    if ($updated) {
      $config->set('enabled_entity_types', $enabled_entity_types);
      $config->save();
      $logger->info('Enabled content translation for WDB entity types.');
    }
  }
  catch (\Exception $e) {
    $logger->error('An error occurred while updating content_translation.settings: @message', ['@message' => $e->getMessage()]);
  }
}

/**
 * Helper function to create default taxonomy terms for WDB vocabularies.
 *
 * @param \Psr\Log\LoggerInterface $logger
 * The logger service.
 */
function create_default_taxonomy_terms($logger) {
  // 1. Create hierarchical terms for 'lexical_category' from a TSV file.
  $vid = 'lexical_category';
  $module_path = \Drupal::moduleHandler()->getModule('wdb_core')->getPath();
  $tsv_file_path = $module_path . '/data/lexical_categories.tsv';

  if (file_exists($tsv_file_path)) {
    $handle = fopen($tsv_file_path, 'r');
    if ($handle !== FALSE) {
      $header = fgetcsv($handle, 0, "\t");
      $created_terms_map = [];

      while (($data = fgetcsv($handle, 0, "\t")) !== FALSE) {
        $row_data = array_combine($header, $data);
        $term_name_en = trim($row_data['name_en']);
        $term_name_ja = trim($row_data['name_ja']);
        $parent_name_en = trim($row_data['parent_en']);
        $gold_ontology_value = trim($row_data['gold_ontology']);

        if (empty($term_name_en)) {
          continue;
        }

        $existing_terms = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->loadByProperties(['vid' => $vid, 'name' => $term_name_en]);
        if (!empty($existing_terms)) {
          continue;
        }

        $parent_tid = 0;
        if (!empty($parent_name_en) && isset($created_terms_map[$parent_name_en])) {
          $parent_tid = $created_terms_map[$parent_name_en];
        }

        try {
          $term_values = [
            'vid' => $vid,
            'name' => $term_name_en,
            'langcode' => 'en',
            'parent' => $parent_tid,
            'field_gold_ontology' => [['value' => $gold_ontology_value]],
          ];
          $term = Term::create($term_values);
          $term->save();

          $created_terms_map[$term_name_en] = $term->id();

          if (!empty($term_name_ja) && \Drupal::languageManager()->isLanguageLocked('ja') === FALSE && $term->hasTranslation('ja') === FALSE) {
            $term->addTranslation('ja', ['name' => $term_name_ja])->save();
          }
          $logger->info('Created hierarchical term "@term" in vocabulary "@vid".', ['@term' => $term_name_en, '@vid' => $vid]);
        }
        catch (\Exception $e) {
          $logger->error('Failed to create hierarchical term "@term": @message', ['@term' => $term_name_en, '@message' => $e->getMessage()]);
        }
      }
      fclose($handle);
    }
  }

  // 2. Define and create terms for other, flat vocabularies.
  $other_vocabularies = [
    'person' => [
      ['en' => 'first', 'ja' => '一人称'],
      ['en' => 'second', 'ja' => '二人称'],
      ['en' => 'third', 'ja' => '三人称'],
    ],
    'grammatical_number' => [
      ['en' => 'singular', 'ja' => '単数'],
      ['en' => 'plural', 'ja' => '複数'],
      ['en' => 'dual', 'ja' => '両数'],
    ],
    'mood' => [
      ['en' => 'indicative', 'ja' => '直説法'],
      ['en' => 'optative', 'ja' => '願望法'],
      ['en' => 'subjunctive', 'ja' => '接続法'],
    ],
    'voice' => [
      ['en' => 'active', 'ja' => '能動態'],
      ['en' => 'passive', 'ja' => '受動態'],
      ['en' => 'middle', 'ja' => '中動態'],
    ],
    'gender' => [
      ['en' => 'masculine', 'ja' => '男性'],
      ['en' => 'feminine', 'ja' => '女性'],
      ['en' => 'neuter', 'ja' => '中性'],
      ['en' => 'common', 'ja' => '通性'],
    ],
    'aspect' => [
      ['en' => 'perfective', 'ja' => '完了相'],
      ['en' => 'imperfective', 'ja' => '未完了相'],
    ],
    'verbal_form' => [
      ['en' => 'stative', 'ja' => '静態'],
      ['en' => 'infinitive', 'ja' => '不定詞'],
      ['en' => 'participle', 'ja' => '分詞'],
      ['en' => 'relative form', 'ja' => '関係形'],
      ['en' => 'base', 'ja' => '基本形'],
    ],
    'grammatical_case' => [
      ['en' => 'nominative', 'ja' => '主格'],
      ['en' => 'accusative', 'ja' => '対格'],
      ['en' => 'dative', 'ja' => '与格'],
      ['en' => 'genitive', 'ja' => '属格'],
    ],
  ];

  foreach ($other_vocabularies as $vid => $terms_to_create) {
    foreach ($terms_to_create as $term_data) {
      $has_translation = is_array($term_data);
      $term_name_en = $has_translation ? $term_data['en'] : $term_data;
      $term_name_ja = $has_translation ? $term_data['ja'] : NULL;

      // Check if a term with the same English name already exists.
      $existing_terms = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->loadByProperties([
        'vid' => $vid,
        'name' => $term_name_en,
      ]);

      if (empty($existing_terms)) {
        try {
          $term = Term::create([
            'vid' => $vid,
            'name' => $term_name_en,
            'langcode' => 'en', // Create with English as the primary language.
          ]);
          $term->save();

          // Add the Japanese translation.
          if ($term_name_ja && \Drupal::languageManager()->getLanguage('ja') && $term->hasTranslation('ja') === FALSE) {
            $term->addTranslation('ja', ['name' => $term_name_ja])->save();
          }
          $logger->info('Created term "@term" (and its Japanese translation) in vocabulary "@vid".', ['@term' => $term_name_en, '@vid' => $vid]);
        }
        catch (\Exception $e) {
          $logger->error('Failed to create term "@term" in vocabulary "@vid": @message', [
            '@term' => $term_name_en,
            '@vid' => $vid,
            '@message' => $e->getMessage(),
          ]);
        }
      }
    }
  }
}

/**
 * Implements hook_update_N().
 *
 * Remove the legacy 'original_label_id' field from the wdb_label entity.
 */
function wdb_core_update_10001() {
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $field_storage_definition = $entity_definition_update_manager->getFieldStorageDefinition('original_label_id', 'wdb_label');
  if ($field_storage_definition) {
    $entity_definition_update_manager->uninstallFieldStorageDefinition($field_storage_definition);
    return t('The legacy original_label_id field has been removed.');
  }
  return t('The legacy original_label_id field was already removed.');
}

/**
 * Implements hook_update_N().
 *
 * Remove the legacy 'image_extension' field from the wdb_annotation_page entity.
 */
function wdb_core_update_10002() {
  $entity_definition_update_manager = \Drupal::service('entity.definition_update_manager');
  $field_storage_definition = $entity_definition_update_manager->getFieldStorageDefinition('image_extension', 'wdb_annotation_page');
  if ($field_storage_definition) {
    $entity_definition_update_manager->uninstallFieldStorageDefinition($field_storage_definition);
    return t("The legacy 'image_extension' field has been removed from the WDB Annotation Page entity.");
  }
  return t("The legacy 'image_extension' field was already removed.");
}

/**
 * Strip HTML from existing rich-text values in description / explanation fields.
 */

/**
 * Add a composite unique index for WdbSignFunction.
 *
 * Ensures database-level enforcement matching the application-level
 * WdbCompositeUnique validator (sign_ref + function_name) while also
 * including langcode for clarity / future-proofing. Because the entity is
 * translatable but both sign_ref and function_name are NOT translatable,
 * duplicates would only arise in the base table. We normalize NULL
 * function_name values to empty string prior to adding the unique key to
 * avoid duplicate NULL groups.
 */
function wdb_core_update_10003() {
  $connection = \Drupal::database();
  $schema = $connection->schema();
  $table = 'wdb_sign_function';
  $unique_key_name = 'wdb_sign_func__uniq_sign_ref_fn_lang';

  // 1. Normalize NULL function_name values to empty string for consistency
  //    with preSave() behavior (and to allow the unique key to be added).
  try {
    $connection->update($table)
      ->fields(['function_name' => ''])
      ->isNull('function_name')
      ->execute();
  }
  catch (\Exception $e) {
    \Drupal::logger('wdb_core')->warning('Failed to normalize NULL function_name values: @msg', ['@msg' => $e->getMessage()]);
  }

  // 2. Detect and collapse duplicates (same sign_ref + function_name + langcode).
  //    Keep the lowest id (oldest record) and delete the rest.
  try {
    $duplicate_query = $connection->select($table, 'sf');
    $duplicate_query->addField('sf', 'sign_ref');
    $duplicate_query->addField('sf', 'function_name');
    $duplicate_query->addField('sf', 'langcode');
    $duplicate_query->addExpression('COUNT(*)', 'dupe_count');
    $duplicate_query->groupBy('sign_ref');
    $duplicate_query->groupBy('function_name');
    $duplicate_query->groupBy('langcode');
    $duplicate_query->having('COUNT(*) > 1');
    $dupe_rows = $duplicate_query->execute()->fetchAll();

    foreach ($dupe_rows as $dupe) {
      $ids_query = $connection->select($table, 'sf2')
        ->fields('sf2', ['id'])
        ->condition('sign_ref', $dupe->sign_ref)
        ->condition('function_name', $dupe->function_name)
        ->condition('langcode', $dupe->langcode)
        ->orderBy('id', 'ASC');
      $ids = $ids_query->execute()->fetchCol();
      if (count($ids) > 1) {
        $keep_id = array_shift($ids); // Preserve the earliest.
        // Delete the remaining duplicate IDs.
        $connection->delete($table)
          ->condition('id', $ids, 'IN')
          ->execute();
        \Drupal::logger('wdb_core')->notice('Removed @count duplicate wdb_sign_function rows for sign_ref=@sign_ref, function_name="@fn", langcode=@lang (kept id=@keep).', [
          '@count' => count($ids),
            '@sign_ref' => $dupe->sign_ref,
            '@fn' => $dupe->function_name,
            '@lang' => $dupe->langcode,
            '@keep' => $keep_id,
        ]);
      }
    }
  }
  catch (\Exception $e) {
    \Drupal::logger('wdb_core')->error('Error collapsing duplicate wdb_sign_function rows: @msg', ['@msg' => $e->getMessage()]);
    // Continue; attempt to add the index anyway (may still fail, surfacing issue).
  }

  // 3. Add the unique key if not already present.
  // Schema API exposes indexExists() which also returns TRUE for unique keys
  // (internally stored as indexes). So we just check indexExists().
  if (!$schema->indexExists($table, $unique_key_name)) {
    try {
      $schema->addUniqueKey($table, $unique_key_name, ['sign_ref', 'function_name', 'langcode']);
    }
    catch (\Exception $e) {
      \Drupal::logger('wdb_core')->error('Failed adding unique key (@name) on @table: @msg', [
        '@name' => $unique_key_name,
        '@table' => $table,
        '@msg' => $e->getMessage(),
      ]);
      return t('Attempted to add unique key, but an error occurred. Check logs.');
    }
    return t('Added unique key (@name) on @table (sign_ref, function_name, langcode).', ['@name' => $unique_key_name, '@table' => $table]);
  }

  return t('Unique key (@name) already exists on @table.', ['@name' => $unique_key_name, '@table' => $table]);
}

/**
 * Normalize NULL function_name values in field data and enforce uniqueness.
 *
 * Rationale: The existing unique index on the data table is
 * (langcode, sign_ref, function_name). In MySQL, UNIQUE permits multiple
 * rows where a column is NULL, so past rows with function_name IS NULL
 * bypassed logical uniqueness. Current preSave() normalizes blanks to '' but
 * legacy rows remain. We (1) collapse duplicate NULL groups per
 * (langcode, sign_ref), then (2) set remaining NULLs to ''. This lets the
 * existing unique index start enforcing the intended rule.
 */
function wdb_core_update_10004() {
  $connection = \Drupal::database();
  $table = 'wdb_sign_function_field_data';
  $logger = \Drupal::logger('wdb_core');
  $deleted_total = 0;
  $normalized_total = 0;

  // 1. Identify duplicate groups among NULL function_name rows.
  try {
    $dupe_query = $connection->select($table, 'sf');
    $dupe_query->addField('sf', 'sign_ref');
    $dupe_query->addField('sf', 'langcode');
    $dupe_query->addExpression('COUNT(*)', 'dupe_count');
    $dupe_query->isNull('function_name');
    $dupe_query->groupBy('sign_ref');
    $dupe_query->groupBy('langcode');
    $dupe_query->having('COUNT(*) > 1');
    $dupes = $dupe_query->execute()->fetchAll();

    foreach ($dupes as $row) {
      $ids_query = $connection->select($table, 'sf2')
        ->fields('sf2', ['id'])
        ->condition('sign_ref', $row->sign_ref)
        ->condition('langcode', $row->langcode)
        ->isNull('function_name')
        ->orderBy('id', 'ASC');
      $ids = $ids_query->execute()->fetchCol();
      if (count($ids) > 1) {
        $keep_id = array_shift($ids);
        if (!empty($ids)) {
          $connection->delete($table)
            ->condition('id', $ids, 'IN')
            ->condition('langcode', $row->langcode)
            ->execute();
          $deleted_total += count($ids);
          $logger->notice('Removed @count duplicate NULL function_name rows for sign_ref=@sign_ref langcode=@lang (kept id=@keep).', [
            '@count' => count($ids),
            '@sign_ref' => $row->sign_ref,
            '@lang' => $row->langcode,
            '@keep' => $keep_id,
          ]);
        }
      }
    }
  }
  catch (\Exception $e) {
    $logger->error('Failed while collapsing NULL function_name duplicates: @msg', ['@msg' => $e->getMessage()]);
  }

  // 2. Convert remaining NULL function_name values to ''.
  try {
    $normalized_total = $connection->update($table)
      ->fields(['function_name' => ''])
      ->isNull('function_name')
      ->execute();
  }
  catch (\Exception $e) {
    $logger->error('Failed normalizing NULL function_name values: @msg', ['@msg' => $e->getMessage()]);
  }

  return t('wdb_core_update_10004: Deleted @deleted duplicates; normalized @normalized NULL function_name rows to empty string.', [
    '@deleted' => $deleted_total,
    '@normalized' => $normalized_total,
  ]);
}
